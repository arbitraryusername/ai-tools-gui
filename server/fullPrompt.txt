
Source code for my project is given below between 'SOURCE_START' and 'SOURCE_END'.
Your specific instructions for exactly how to add, update, or delete code from my project's source code is between 'TASK_START' and 'TASK_END'.
If the text between 'TASK_START' and 'TASK_END' contradict the instructions in this top section, then follow this top set of instructions.
In the source code, lines starting with ~~ are paths to files, followed by that file's content on the next line.
Your output should only contain ~~put_file_path_here followed by the updated contents of that file.
It is critially important that you include the entire file's content in your response if that file should be updated.
Do not give other output except for that, meaning no explanation or markup.
Existing project dependencies are provided. Reuse existing dependencies when applicable.
Add or remove dependencies to the package.json when needed, and provide the entire file in the response with only the needed changes.
If there is a corresponding @types package for the added package, then also include this @types package in the package.json file.
NEVER put comments in JSON files. Do not add comments in the code. Do not remove existing comments.
If a file should be removed entirely, include ~~file_path on its own line, followed by a blank line.
TASK_START
add an http endpoint /api/revertLastCommit to index.ts, which should call the existing function in GitHelper. if the commit was reverted successfully, then return true to the caller of the http endpoint. otherwise return false.
TASK_END
SOURCE_START

~~server/nodemon.json
{
  "watch": ["src"],
  "ext": "ts",
  "exec": "node --inspect --loader ts-node/esm src/index.ts",
  "ignore": ["dist"]
}

~~server/package.json
{
  "name": "@ai-tools-gui/server",
  "version": "1.0.0",
  "type": "module",
  "description": "Backend server for the project",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "build:shared": "pnpm --filter shared build",
    "start": "node dist/index.js",
    "dev": "nodemon"
  },
  "dependencies": {
    "@ai-tools-gui/shared": "workspace:*",
    "@types/cors": "^2.8.17",
    "@types/cross-spawn": "^6.0.6",
    "@types/express": "^4.17.21",
    "cors": "^2.8.5",
    "cross-spawn": "^7.0.6",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "ignore": "^7.0.0",
    "openai": "^4.76.3",
    "simple-git": "^3.27.0"
  },
  "devDependencies": {
    "@types/gitignore-parser": "^0.0.3",
    "@types/node": "^20.4.0",
    "nodemon": "^3.1.9",
    "ts-node": "^10.9.2"
  }
}
~~server/src/AppConfig.ts
import { fileURLToPath } from 'url';
import path from 'path';
import dotenv from 'dotenv';

dotenv.config();

const FILE_PATH_DELIMITER = "~~" as const;

export function getCurrentDirectory(): string {
  const __filename = fileURLToPath(import.meta.url);
  return path.dirname(__filename);
}

export function getSourceCodeRelativePath(): string {
  const relativePath = process.env.SOURCE_CODE_RELATIVE_PATH;
  if (!relativePath) {
    throw new Error('SOURCE_CODE_RELATIVE_PATH environment variable is not set');
  }
  return relativePath;
}

/**
 * Retrieves the absolute path to the source code directory with forward slashes.
 *
 * @returns The absolute path with forward slashes
 * @throws Error if required environment variables are not set
 */
export function getSourceCodeAbsolutePath(): string {
  const currentDirectory = getCurrentDirectory();
  const sourceCodeRelativePath = getSourceCodeRelativePath();
  
  const absolutePath = path.resolve(currentDirectory, sourceCodeRelativePath);
  return absolutePath.split(path.sep).join('/');
}

export function getOpenAiKey(): string {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error('OPENAI_API_KEY environment variable is not set');
  }
  return apiKey;
}

export function getFilePathDelimiter(): string {
  return FILE_PATH_DELIMITER;
}

export type { FilePathDelimiter };
type FilePathDelimiter = typeof FILE_PATH_DELIMITER;
~~server/src/DevServerManager.ts
import { spawn, ChildProcess } from 'child_process';

class DevServerManager {
  private process: ChildProcess | null = null;

  /**
   * Starts the dev server using "pnpm dev" and keeps a reference to the process.
   * @param targetDir The directory where the command should run.
   * @returns A promise that resolves when the process starts successfully or rejects on error.
   */
  async startDevServer(targetDir: string): Promise<void> {
    if (this.process) {
      console.warn("Dev server is already running.");
      return;
    }

    return new Promise((resolve, reject) => {
      console.log(`Starting dev server in directory: ${targetDir}`);
      this.process = spawn('pnpm', ['dev'], {
        cwd: targetDir,
        shell: true,
        stdio: 'inherit',
      });

      this.process.on('spawn', () => {
        console.log('Dev server started successfully.');
        resolve();
      });

      this.process.on('error', (err) => {
        console.error('Failed to start dev server:', err);
        this.process = null;
        reject(err);
      });

      this.process.on('close', (code) => {
        console.log(`Dev server stopped with exit code ${code}`);
        this.process = null;
      });
    });
  }

  /**
   * Stops the running dev server if it exists.
   * @returns A promise that resolves when the process is stopped or rejects if no process is running.
   */
  async stopDevServer(): Promise<void> {
    if (!this.process) {
      console.warn("No dev server is currently running.");
      return Promise.reject(new Error("No dev server is currently running."));
    }

    return new Promise((resolve, reject) => {
      console.log("Stopping dev server...");
      this.process?.on('close', (code) => {
        console.log(`Dev server stopped with exit code ${code}`);
        this.process = null;
        resolve();
      });

      try {
        this.process?.kill('SIGINT'); // Graceful termination signal
      } catch (err) {
        console.error('Failed to stop dev server:', err);
        reject(err);
      }
    });
  }

  /**
   * Checks if the dev server is running.
   * @returns True if the dev server process exists, false otherwise.
   */
  isDevServerRunning(): boolean {
    return this.process !== null;
  }
}

// Usage example
export const devServerManager = new DevServerManager();

~~server/src/GitUtils.ts
import simpleGit, { SimpleGit } from 'simple-git';
import { GitCommit } from '@ai-tools-gui/shared';


/**
 * Creates a new Git commit in the specified repository.
 * Formats the returned GitCommit object to align with `getLastCommits`.
 * @param commitMessage - The commit message.
 * @param repoAbsolutePath - The absolute path to the Git repository.
 * @returns A promise that resolves to the created GitCommit object.
 */
export async function createGitCommit(
  commitMessage: string,
  repoAbsolutePath: string
): Promise<GitCommit> {
  try {
    const git: SimpleGit = simpleGit(repoAbsolutePath);

    // Stage all changes
    await git.add('./*');

    // Commit changes
    const commitResult = await git.commit(commitMessage);
    const hash = commitResult.commit;

    // Retrieve the full diff for the commit
    const fullCommitOutput = await git.show([hash, '--patch', '--no-color']);
    const diff = preprocessDiff(fullCommitOutput); // Format diff for react-diff-view

    // Retrieve the commit timestamp
    const timestamp = new Date(
      (await git.show(['-s', '--format=%ct', hash])).trim() + '000'
    );

    console.debug(`Commit ${hash} created with message: "${commitMessage}"`);

    return {
      hash,
      message: commitMessage,
      diff,
      timestamp,
    };
  } catch (error) {
    throw new Error(
      `Failed to create git commit in repository at "${repoAbsolutePath}". Reason: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

export async function revertLastCommit(
  repoAbsolutePath: string
): Promise<GitCommit> {
  try {
    const git: SimpleGit = simpleGit(repoAbsolutePath);

    const currentCommitHash = (await git.revparse(['HEAD'])).trim();
    const commitMessage = await git.show(['-s', '--format=%B', currentCommitHash]);
    const commitDiff = await git.show([currentCommitHash]);
    const timestamp = new Date((await git.show(['-s', '--format=%ct', currentCommitHash])).trim() + '000');

    await git.reset(['--hard', 'HEAD~1']);

    console.log(`Successfully reverted the most recent commit: ${currentCommitHash}`);
    
    return {
      hash: currentCommitHash,
      message: commitMessage.trim(),
      diff: commitDiff,
      timestamp
    };
  } catch (error) {
    throw new Error(`Failed to revert the most recent commit in repository at "${repoAbsolutePath}". Reason: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Fetches the last `count` commits from the target Git repository.
 * @param repoAbsolutePath - The absolute path to the Git repository.
 * @param count - The number of commits to retrieve.
 * @returns A promise that resolves to an array of the last `count` commits.
 */
export async function getLastCommits(
  repoAbsolutePath: string,
  count: number
): Promise<GitCommit[]> {
  try {
    const git: SimpleGit = simpleGit(repoAbsolutePath);

    // Fetch the specified number of commits
    const log = await git.log({ maxCount: count });

    // Map each commit to a GitCommit object with detailed diff and timestamp
    const commits: GitCommit[] = await Promise.all(
      log.all.map(async (entry) => {
        // Retrieve full diff for the commit
        const fullCommitOutput = await git.show([entry.hash, '--patch', '--no-color']);
        const diff = preprocessDiff(fullCommitOutput); // Format diff for react-diff-view
        const timestamp = new Date(entry.date);

        return {
          hash: entry.hash,
          message: entry.message,
          diff,
          timestamp,
        };
      })
    );

    console.log(`Fetched the last ${count} commits from the repository at "${repoAbsolutePath}"`);
    return commits;
  } catch (error) {
    throw new Error(
      `Failed to fetch the last ${count} commits in repository at "${repoAbsolutePath}". Reason: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

/**
 * Preprocesses the git show output to format it correctly for react-diff-view.
 * Removes commit metadata and retains only the unified diff content.
 * @param fullCommitOutput - The raw git show output.
 * @returns The processed diff string.
 */
function preprocessDiff(fullCommitOutput: string): string {
  const lines = fullCommitOutput.split('\n');
  const startDiffIndex = lines.findIndex((line) => line.startsWith('diff --git'));
  return startDiffIndex >= 0 ? lines.slice(startDiffIndex).join('\n') : '';
}

~~server/src/index.ts
import express, { NextFunction } from 'express';
import cors from 'cors';
import { promptProcessor } from './PromptProcessor.js';
import { Request, Response } from 'express';
import { 
  ProcessPromptErrorResponse,
  ProcessPromptResult,
  ProcessPromptSuccessResponse
} from 'types.js';
import { devServerManager } from './DevServerManager.js';
import { getLastCommits } from './GitUtils.js';
import { getSourceFiles } from './SourceCodeHelper.js';

const app = express();
const PORT = 3001;

app.use(cors());
app.use(express.json());

app.listen(PORT, () => {
  console.log(`Server is running at http://localhost:${PORT}`);
});

const asyncHandler = (fn: Function) => (req: Request, res: Response, next: NextFunction) =>
  Promise.resolve(fn(req, res, next)).catch(next);

app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error("Unhandled error:", err);
  res.status(500).json({ commits: [], error: 'Internal Server Error' });
});

// app.post('/api/startApp', asyncHandler(async (req: Request, res: Response) => {
//   const { sourceAbsolutePath } = req.body;
//   if (!sourceAbsolutePath) {
//     return res.status(400).json({ error: 'Missing "sourceAbsolutePath" parameter.' });
//   }

//   await devServerManager.startDevServer(sourceAbsolutePath);
//   res.json({ success: true });
// }));

// app.post('/api/stopApp', asyncHandler(async (req: Request, res: Response) => {
//   await devServerManager.stopDevServer();
//   res.json({ success: true });
// }));

app.post('/api/processPrompt', asyncHandler(async (req: Request, res: Response) => {
  console.log('/api/processPrompt -> req.body: ', JSON.stringify(req.body));

  const { prompt, sourceAbsolutePath, selectedFilePaths } = req.body;
  if (!prompt) {
    return res.status(400).json({ commits: [], error: 'Missing "prompt" parameter.' });
  }
  if (!sourceAbsolutePath) {
    return res.status(400).json({ commits: [], error: 'Missing "sourceAbsolutePath" parameter.' });
  }
  if (!selectedFilePaths?.length) {
    return res.status(400).json({ commits: [], error: 'Parameter "selectedFilePaths" must be a non empty list.' });
  }

  const result: ProcessPromptResult = await promptProcessor.process(prompt, sourceAbsolutePath, selectedFilePaths);

  if ('error' in result) {
    return res.status(500).json(result as ProcessPromptErrorResponse);
  }

  return res.json(result as ProcessPromptSuccessResponse);
}));

app.get('/api/commits', asyncHandler(async (req: Request, res: Response) => {
  const sourceAbsolutePath = req.query.sourceAbsolutePath as string;

  if (!sourceAbsolutePath) {
    return res.status(400).json({ error: 'Missing "sourceAbsolutePath" query parameter.' });
  }

  const commits = await getLastCommits(sourceAbsolutePath, 10);
  res.json(commits);
}));

app.get('/api/sourceFiles', asyncHandler(async (req: Request, res: Response) => {
  const sourceAbsolutePath = req.query.sourceAbsolutePath as string;

  if (!sourceAbsolutePath) {
    return res.status(400).json({ error: 'Missing "sourceAbsolutePath" query parameter.' });
  }

  const files = await getSourceFiles(sourceAbsolutePath);
  res.json(files);
}));

~~server/src/OpenAIAPI.ts
import OpenAI from 'openai';
import { getOpenAiKey } from './AppConfig.js';
import { Model } from 'types.js';

const MODELS: Model[] = [
  {
    id: 'gpt-4o-mini',
    inputCost: 0.150,
    outputCost: 0.60
  },
  {
    id: 'gpt-4o',
    inputCost: 2.50,
    outputCost: 10.00
  },
  {
    id: 'o1-mini',
    inputCost: 3.00,
    outputCost: 12.00
  },
  {
    id: 'o1',
    inputCost: 15.00,
    outputCost: 60.00
  }
] as const;

class OpenAIService {
  private readonly client: OpenAI;

  constructor() {
    const apiKey = getOpenAiKey();
    this.client = new OpenAI({ apiKey });
  }

  async generateCode(prompt: string): Promise<string> {
    try {
      const chatCompletion = await this.client.chat.completions.create({
        model: MODELS[0].id,
        messages: [{ role: 'user' as const, content: prompt }],
      });

      const generatedResponse = chatCompletion.choices[0].message.content;
      console.log("DEBUG returning generatedResponse:", generatedResponse);

      const extractedCode = this.stripMarkdown(generatedResponse || '');
      console.log("DEBUG: Extracted Code:", extractedCode);

      return extractedCode;
    } catch (error) {
      console.error(
        "Error calling OpenAI API:",
        error instanceof Error ? error.message : String(error)
      );
      throw error;
    }
  }

  private stripMarkdown(text: string): string {
    const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)\n```/g;
    let extractedCode = '';
    let match: RegExpExecArray | null;

    while ((match = codeBlockRegex.exec(text)) !== null) {
      if (match[1]) {
        extractedCode += match[1].trim() + '\n';
      }
    }

    return extractedCode.length > 0 ? extractedCode.trim() : text;
  }
}

const openAIService = new OpenAIService();
export const generateCode = (prompt: string) => openAIService.generateCode(prompt);
export type { Model };
~~server/src/PromptProcessor.ts
import { writeFile } from 'fs/promises';
import { getFilePathDelimiter } from './AppConfig.js';
import { combineFilesIntoString, applyChangesToSourceCode } from './SourceCodeHelper.js';
import { generateCode } from './OpenAIAPI.js';
import { executeCommand } from './ShellUtils.js';
import { createGitCommit } from './GitUtils.js';
import { ProcessPromptOptions, ProcessPromptResult } from 'types.js';
import { GitCommit } from '@ai-tools-gui/shared';
import { devServerManager } from './DevServerManager.js';

// Constants
const BUILD_COMMAND = "pnpm build" as const;
const DEV_COMMAND = "pnpm dev" as const;
const INSTALL_COMMAND = "pnpm install" as const;

class PromptProcessor {
  private readonly delimiter: string;

  constructor() {
    this.delimiter = getFilePathDelimiter();
  }

  async process(
    rawPrompt: string,
    sourceAbsolutePath: string,
    selectedFilePaths: string[],
    // options: ProcessPromptOptions = {}
  ): Promise<ProcessPromptResult> {
    const commits: GitCommit[] = [];
    // const { maxErrorResolutionAttempts = 1 } = options;
  
    // console.debug("DEBUG starting to process userRawPrompt:", rawPrompt);
  
    try {
      const fullPrompt = await this.generateFullPrompt(rawPrompt, sourceAbsolutePath, selectedFilePaths);
      // console.log("DEBUG fullPrompt:\n\n", fullPrompt);
      await writeFile('./fullPrompt.txt', fullPrompt, 'utf8');

      // return { commits: [] };

      const generatedCode = await generateCode(fullPrompt);
  
      await applyChangesToSourceCode(generatedCode, sourceAbsolutePath);
  
      if (this.containsPackageJsonChanges(generatedCode)) {
        console.log("package.json updates found");
        // await devServerManager.stopDevServer();
        // await executeCommand(INSTALL_COMMAND, sourceAbsolutePath);
      }
  
      const commitMessage = `PROMPT: ${rawPrompt}`;
      const initialCommit = await createGitCommit(
        commitMessage,
        sourceAbsolutePath, 
      );
      commits.push(initialCommit);

      // await executeCommand(BUILD_COMMAND, sourceAbsolutePath);
      // build command didn't throw error, so start the dev server(s)
      // await devServerManager.startDevServer(sourceAbsolutePath);

      // TODO: use auto build error resolution code
  
      // const buildResolutionCommits = await this.handleBuildProcess(
      //   userRawPrompt,
      //   sourceAbsolutePath,
      //   maxErrorResolutionAttempts
      // );
  
      // commits.push(...buildResolutionCommits);
  
      return { commits };
    } catch (error) {
      console.error("Error processing prompt:", error);
      return {
        commits,
        error: `Failed to process prompt: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  private async generateFullPrompt(
    userRawPrompt: string,
    sourceAbsolutePath: string,
    selectedFilePaths: string[],
  ): Promise<string> {
    const promptInstructions = `
Source code for my project is given below between 'SOURCE_START' and 'SOURCE_END'.
Your specific instructions for exactly how to add, update, or delete code from my project's source code is between 'TASK_START' and 'TASK_END'.
If the text between 'TASK_START' and 'TASK_END' contradict the instructions in this top section, then follow this top set of instructions.
In the source code, lines starting with ${this.delimiter} are paths to files, followed by that file's content on the next line.
Your output should only contain ${this.delimiter}put_file_path_here followed by the updated contents of that file.
It is critially important that you include the entire file's content in your response if that file should be updated.
Do not give other output except for that, meaning no explanation or markup.
Existing project dependencies are provided. Reuse existing dependencies when applicable.
Add or remove dependencies to the package.json when needed, and provide the entire file in the response with only the needed changes.
If there is a corresponding @types package for the added package, then also include this @types package in the package.json file.
NEVER put comments in JSON files. Do not add comments in the code. Do not remove existing comments.
If a file should be removed entirely, include ${this.delimiter}file_path on its own line, followed by a blank line.`;

    const projectContentString = await combineFilesIntoString(sourceAbsolutePath, selectedFilePaths);

    return `${promptInstructions}\nTASK_START\n${userRawPrompt}\nTASK_END\nSOURCE_START\n${projectContentString}\nSOURCE_END`;
  }

  // private async handleBuildProcess(
  //   userRawPrompt: string,
  //   sourceAbsolutePath: string,
  //   maxAttempts: number
  // ): Promise<GitCommit[]> {
  //   let attempts = 0;
  //   const commits: GitCommit[] = [];

  //   while (attempts < maxAttempts) {
  //     try {
  //       await executeCommand(BUILD_COMMAND, sourceAbsolutePath);
  //       return []; // no new commits to make
  //     } catch (error) {
  //       attempts++;
  //       console.error(`Build attempt ${attempts} failed:`, error);

  //       if (attempts < maxAttempts) {
  //         await this.attemptBuildErrorResolution(
  //           error instanceof Error ? error.message : String(error),
  //           sourceAbsolutePath
  //         );
          
  //         const errorResolutionCommit = await createGitCommit(
  //           `Attempt ${attempts} to auto resolve build error from previous commit: ${userRawPrompt}`,
  //           sourceAbsolutePath
  //         );
  //         commits.push(errorResolutionCommit);
  //       } else {
  //         throw new Error(`Build failed after ${maxAttempts} attempts`);
  //       }
  //     }
  //   }

  //   return commits;
  // }

//   private async attemptBuildErrorResolution(buildCommandOutput: string, sourceAbsolutePath: string): Promise<void> {
//     const errorResolutionPrompt = this.generateErrorResolutionPrompt(buildCommandOutput, sourceAbsolutePath);
    
//     console.log("DEBUG errorResolutionPrompt:", errorResolutionPrompt);

//     const generatedCodeToFixBuildErrors = await generateCode(errorResolutionPrompt);
//     await applyChangesToSourceCode(generatedCodeToFixBuildErrors, sourceAbsolutePath);
//   }

//   private generateErrorResolutionPrompt(buildCommandOutput: string, sourceAbsolutePath: string): string {
//     const errorResolutionPromptInstructions = `
// After running command "${BUILD_COMMAND}" I get the error between 'OUTPUT_START' and 'OUTPUT_END' below:
// OUTPUT_START\n${buildCommandOutput}\nOUTPUT_END
// Update my project source code to fix these errors.
// My project source code is given below between 'SOURCE_START' and 'SOURCE_END'.
// In the source code, lines starting with ${this.delimiter} are paths to files, followed by that file's content on the next line.
// Your output should only contain ${this.delimiter}put_file_path_here followed by the updated contents of that file.
// Do not give other output except for that, meaning no explanation or markup. Do not add or remove any comments in the code.`;

//     const projectContentString = combineFilesIntoString(sourceAbsolutePath);

//     return `${errorResolutionPromptInstructions}\nSOURCE_START\n${projectContentString}\nSOURCE_END`;
//   }

  private containsPackageJsonChanges(input: string): boolean {
    const lines = input.split(/\r?\n/);
    return lines.some(line => line.trim() === `${this.delimiter}package.json`);
  }
}

export const promptProcessor = new PromptProcessor();
export type { ProcessPromptOptions };
~~server/src/ShellUtils.ts
import spawn from 'cross-spawn';
import { ChildProcess } from 'child_process';
import { CommandResult } from 'types';

export async function executeCommand(
  command: string,
  targetDir: string
): Promise<CommandResult> {
  return new Promise((resolve, reject) => {
    const [cmd, ...args] = command.split(' ');

    const child: ChildProcess = spawn(cmd, args, {
      cwd: targetDir,
      shell: true,
      stdio: 'pipe'
    });

    let stdout = '';
    let stderr = '';

    if (child.stdout) {
      child.stdout.on('data', (data: Buffer) => {
        stdout += data.toString();
      });
    }

    if (child.stderr) {
      child.stderr.on('data', (data: Buffer) => {
        stderr += data.toString();
      });
    }

    child.on('close', (code: number | null) => {
      if (code === 0) {
        console.log(`Command ${command} @ ${targetDir} succeeded:\n${stdout}`);
        resolve({ stdout, stderr });
      } else {
        console.error(`Command '${command}' @ ${targetDir} failed with exit code ${code}:\nSTDOUT:\n${stdout}\nSTDERR:\n${stderr}`);
        reject(new Error(`${stdout}\n${stderr}`));
      }
    });

    child.on('error', (error: Error) => {
      console.error('Failed to start command:', error);
      reject(error);
    });
  });
}

~~server/src/SourceCodeHelper.ts
import fs from 'fs/promises';
import path from 'path';
import { getFilePathDelimiter } from './AppConfig.js';
import ignore from 'ignore';

const FILE_PROCESSING_CONCURRENCY = 10;

interface FileProcessingError extends Error {
  path?: string;
}

/**
 * Applies code changes by updating or deleting files based on the provided input.
 *
 * @param generatedCodeChanges - The input string containing file delimiters and their corresponding content.
 * @returns A promise that resolves when all operations are successful or throws an error if a problem occurs.
 */
export async function applyChangesToSourceCode(generatedCodeChanges: string, sourceAbsolutePath: string): Promise<void> {
  console.log(`\n\nApplying changes to path ${sourceAbsolutePath}`);

  const delimiter = getFilePathDelimiter();
  const regex = new RegExp(`${delimiter}([^\\r\\n]+)\\r?\\n([\\s\\S]*?)(?=${delimiter}|$)`, 'g');
  const matches = [...generatedCodeChanges.matchAll(regex)];

  console.log(`Total file entries found: ${matches.length}`);

  for (const [index, match] of matches.entries()) {
    const relativeFilePath = match[1]?.trim();
    const content = match[2]?.trim();

    if (!relativeFilePath) {
      console.warn(`Skipping invalid match at index ${index}`);
      continue;
    }

    console.log(`Processing file (${index + 1}/${matches.length}): ${relativeFilePath}`);
    const normalizedPath = path.normalize(relativeFilePath);
    const fullPath = path.resolve(sourceAbsolutePath, normalizedPath);

    console.log(`Resolved full path: ${fullPath}`);

    if (!content) {
      try {
        await fs.unlink(fullPath);
        console.log(`Deleted file: ${fullPath}`);
      } catch (error: any) {
        if (error.code === 'ENOENT') {
          console.log(`File not found, skipping deletion: ${fullPath}`);
        } else {
          throw new Error(`Failed to delete file at ${fullPath}: ${error.message}`);
        }
      }
      continue;
    }

    try {
      const directory = path.dirname(fullPath);
      await fs.mkdir(directory, { recursive: true });
      await fs.writeFile(fullPath, content, 'utf8');
      console.log(`Successfully updated file: ${fullPath}`);
    } catch (error: any) {
      throw new Error(`Failed to process file at ${fullPath}: ${error.message}`);
    }
  }
}

/**
 * Combines content from all allowed files into a single string, separated by delimiters.
 * 
 * @param sourceAbsolutePath - The root directory.
 * @returns A string containing file paths and their contents.
 */
export async function combineFilesIntoString(
  sourceAbsolutePath: string,
  fileRelativePaths: string[]
): Promise<string> {
  const delimiter = getFilePathDelimiter();
  let combinedContent = '';

  try {
    // const excludedPaths = await getExcludedPaths(sourceAbsolutePath);
    // const allowedFiles = await getAllAllowedFiles(sourceAbsolutePath, excludedPaths);

    for (let i = 0; i < fileRelativePaths.length; i += FILE_PROCESSING_CONCURRENCY) {
      const chunk = fileRelativePaths.slice(i, i + FILE_PROCESSING_CONCURRENCY);
      const readTasks = chunk.map(async (fileRelativePath) => {
        try {
          const fileContents = await fs.readFile(path.join(sourceAbsolutePath, fileRelativePath), 'utf-8');
          return `\n${delimiter}${fileRelativePath}\n${fileContents}`;
        } catch (error) {
          const processingError: FileProcessingError = new Error(`Error reading file: ${fileRelativePath}`);
          processingError.path = fileRelativePath;
          processingError.cause = error;
          throw processingError;
        }
      });

      const results = await Promise.all(readTasks);
      combinedContent += results.join('');
    }
  } catch (error) {
    const processingError: FileProcessingError = new Error('Error combining files into string');
    processingError.cause = error;
    throw processingError;
  }

  return combinedContent;
}

export async function getSourceFiles(sourceAbsolutePath: string): Promise<{ name: string; path: string; children?: any[] }[]> {
  const excludedPaths = await getExcludedPaths(sourceAbsolutePath);
  return await getAllAllowedFiles(sourceAbsolutePath, excludedPaths);
}

// ignore these regardless of what the .gitignore says
const ignoredFolders = [
  '.git',
  'node_modules',
];

const ignoredFiles = [
  'LICENSE',
  'package-lock.json',
  'pnpm-lock.yaml',
];

/**
 * Recursively collects all excluded paths based on a .gitignore file.
 * @param sourceAbsolutePath - The root directory containing the .gitignore file.
 * @returns A Set of excluded paths relative to the root directory, using forward slashes.
 */
async function getExcludedPaths(sourceAbsolutePath: string): Promise<Set<string>> {
  // Read and parse the .gitignore file
  const gitignoreContent = await fs.readFile(path.join(sourceAbsolutePath, '.gitignore'), 'utf-8');
  const ignoreParser = ignore();
  ignoreParser.add(gitignoreContent);

  const allExcludedPaths: Set<string> = new Set();

  /**
   * Recursively scans a directory to find excluded paths.
   * @param dir - The directory to scan.
   * @param relativePath - The path relative to the source root.
   */
  async function scanDirectory(dir: string, relativePath = '') {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const entryRelativePath = path.posix.join(relativePath, entry.name); // Use path.posix.join for forward slashes
      const fullPath = path.join(dir, entry.name);

      // Check if the relative path is ignored
      if (
        ignoreParser.ignores(entryRelativePath) || 
        ignoredFolders.includes(entryRelativePath) ||
        ignoredFiles.includes(entry.name)
      ) {
        allExcludedPaths.add(entryRelativePath);
        // Skip further processing of ignored directories
        if (entry.isDirectory()) continue;
      }

      // Recursively scan subdirectories
      if (entry.isDirectory()) {
        await scanDirectory(fullPath, entryRelativePath);
      }
    }
  }

  // Start scanning from the root directory
  await scanDirectory(sourceAbsolutePath);

  console.log("allExcludedPaths: ", allExcludedPaths);

  return allExcludedPaths;
}

/**
 * Recursively retrieves all allowed files that are not in the excludedPaths set.
 * Returns a flat array of file objects with relative paths normalized to use forward slashes.
 * 
 * @param directory - The root directory to scan.
 * @param excludedPaths - A set of paths to exclude (relative to the root directory).
 * @param rootDir - The root directory used for calculating relative paths.
 * @returns A promise resolving to an array of files with names and normalized paths.
 */
async function getAllAllowedFiles(
  directory: string,
  excludedPaths: Set<string>,
  rootDir: string = directory
): Promise<{ name: string; path: string }[]> {
  const allowedFiles: { name: string; path: string }[] = [];

  const entries = await fs.readdir(directory, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(directory, entry.name);
    const relativePath = path.posix.join(path.relative(rootDir, fullPath).split(path.sep).join('/'));

    if (excludedPaths.has(relativePath)) {
      // Skip excluded files and directories
      continue;
    }

    if (entry.isFile()) {
      // Add files to the result
      allowedFiles.push({ name: entry.name, path: relativePath });
    } else if (entry.isDirectory()) {
      // Recurse into subdirectories
      const children = await getAllAllowedFiles(fullPath, excludedPaths, rootDir);
      allowedFiles.push(...children);
    }
  }

  return allowedFiles;
}
~~server/src/types.ts
import { GitCommit } from '@ai-tools-gui/shared';

export interface CommandResult {
  stdout: string;
  stderr: string;
}

export interface Model {
  id: string;
  inputCost: number;
  outputCost: number;
}

export interface ProcessPromptOptions {
  maxErrorResolutionAttempts?: number;
}

export interface ProcessPromptSuccessResponse {
  commits: GitCommit[];
}

export interface ProcessPromptErrorResponse {
  error: string;
  commits: GitCommit[]; // commits could be made but some problem occurs later
}

export type ProcessPromptResult = ProcessPromptSuccessResponse | ProcessPromptErrorResponse;

export interface ProcessPromptBody {
  prompt: string;
  sourceAbsolutePath: string;
}

~~server/tsconfig.json
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "outDir": "./dist",
    "rootDir": "./src",
    "sourceMap": true,
    "baseUrl": "./src",
    "useDefineForClassFields": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

SOURCE_END